\chapter{Conclusion}

\par Overall, while the project was long and arduous,  we made many mistakes along the way and we learned a lot as well. 

\par We were able to achieve our goal, in creating a web application that made viewing sports highlights a much simpler, more efficient, and user friendly experience. We were able to set up an instance with Elasticsearch, connect it to our Node server, launch the express JS framework, and visualize all the back end data on Kibana (all relatively new tools that we were able to learn along the way). We were able to work with Google’s Firebase, in order to create a user customization feature so that users can view videos that would be interesting to them. Most importantly, we were able to see out a project that looked delightful as a mock up and put it in production mode, launched as an Amazon EC2 instance. 

\par Along the way, many obstacles came our way, and we had to find ways to get around them. That being said, we were able to remember what they were, and learn from them in the future. First and foremost, we learned that we need to allocate more time for deployment purposes. When initially creating our Gantt Chart, we underestimated the time it would take to deploy both our ElasticSearch instance as well as our Node server. This led to a lot of unnecessary stress, and could have been avoided, had we allocated more time. Secondly, we learned that we needed to properly and more frequently push our code to the version control system. Sometimes we got caught in developing our own respective part of the project, and when we both pushed, there were a lot of merge errors. If we had pushed our code more frequently, this would have been avoided. Next, we learned that we need to use our technology stack to its full potential. Essentially, we set up an ExpressJS application; however, we found ourselves sometimes writing external JS files to do a mini task. This is not what Express was meant to do, and we believe the request payloads throughout our application could have been smaller should we have stuck to programming the “Express way”. Lastly, we learned that we should not over complicate the problem. Whereas ElasticSearch is a great modern tool to use, its use could have been avoided, for we really didn’t need an indexable search engine running in our back end. Something like SQL would have done the job as well in this application. 

\par We encountered many  cross origin resource sharing (CORS) errors when initially testing our application, and did not really understand what was going on. One thing that could have been done better is to truly understand what was going on under the hood, instead of finding ways around that. In addition to that, the application, in its current state, is not mobile responsive yet, and that could/should have been completed. Learning more about how Elasticsearch scales is also another thing that could have been done. Elasticsearch uses a lot of new terminology, like “shards”, “documents”, and “mappings”, and it's important to know those to understand how to scale fast, should a lot of users be on our application making requests. Lastly, we could have gotten rid of all our external public Javascript files, and embedded that in the ExpressJS routes. That would have decreased our request payload, and simplified a lot of the code. 

\par For the future, we need to make the application mobile responsive, clean up the code base, understand everything regarding cross origin resource sharing, and lastly, understand how to scale the Elasticsearch, should that be necessary. Overall, this project has been a blast, and we have both been exposed to many new technologies that we previously did not know. Throughout the process, we ran into some obstacles, but we’re happy to say we always found ways to get through and around them. 